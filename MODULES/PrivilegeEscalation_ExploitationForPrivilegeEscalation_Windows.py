# -*- coding: utf-8 -*-
# @File  : SimplePostPythonModule.py
# @Date  : 2019/1/12
# @Desc  :

import os
import re
import sqlite3

from Lib.ModuleAPI import *


class PostModule(PostMSFPowershellModule):
    NAME_ZH = "搜索系统可利用CVE"
    DESC_ZH = "模块通过内存执行powershell脚本查看系统版本信息及补丁信息,\n" \
              "与数据库中的数据对比,删选系统可能受那些CVE漏洞影响"
    REQUIRE_SESSION = True
    MODULETYPE = TAG2TYPE.Privilege_Escalation
    PLATFORM = ["Windows"]  # 平台
    PERMISSIONS = ["User", "Administrator", ]  # 所需权限
    ATTCK = ["T1068"]  # ATTCK向量
    README = ["https://www.yuque.com/vipersec/module/zz0fl8"]
    REFERENCES = ["https://attack.mitre.org/techniques/T1068/",
                  "https://github.com/chroblert/WindowsVulnScan"]
    AUTHOR = "Viper"

    OPTIONS = register_options([
        OptionInt(name='timeout', name_tag="脚本超时时间(秒)", desc="脚本执行的超时时间(5-3600)", required=True, default=60),
    ])

    def __init__(self, sessionid, ipaddress, custom_param):
        super().__init__(sessionid, ipaddress, custom_param)

    def check(self):
        """执行前的检查函数"""

        self.set_script("KBCollects.ps1")

        timeout = self.param("timeout")
        # 检查timeout
        if timeout < 5 or timeout > 3600:
            return False, "输入的模块超时时间有误(最小值60,最大值3600),请重新输入"
        self.set_script_timeout(timeout)

        session = Session(self._sessionid)
        if session.is_alive:
            pass
        else:
            return False, "Session不可用"
        if session.is_windows:
            return True, None
        else:
            return False, "模块只支持Windows系统"

    def select_CVE(self, KBList=[], windowsProductName="", windowsVersion=""):
        DBFileName = os.path.join(self.module_data_dir, "CVEKB.db")
        TableName = "CVEKB"
        conn = sqlite3.connect(DBFileName)
        con = conn.cursor()
        intersectionList = []
        count = 0
        for i in KBList:
            if windowsVersion is None:
                sql = 'select distinct(CVEName) from ' + TableName + ' where (name like "' + windowsProductName + '%") and ("' + i + '" not in (select KBName from ' + TableName + ' where name like "' + windowsProductName + '%")); '
            else:
                sql = 'select distinct(CVEName) from ' + TableName + ' where (name like "' + windowsProductName + '%' + windowsVersion + '%") and ("' + i + '" not in (select KBName from ' + TableName + ' where name like "' + windowsProductName + '%' + windowsVersion + '%")); '
            cveList = []
            for cve in con.execute(sql):
                cveList.append(cve[0])
            if count == 0:
                intersectionList = cveList.copy()
            count += 1
            intersectionList = list(set(intersectionList).intersection(set(cveList)))
        intersectionList.sort()
        for cve in intersectionList:
            sql = "select CVEName,impact from {} where CVEName == '{}' and hasPOC == 'True'".format(TableName, cve)
            # print(sql)
            con.execute(sql)
            data = con.fetchall()
            if len(data) != 0:
                self.log_good(f"CVE编号:{data[0][0]} 漏洞类型:{data[0][1]}".format(cve))

    def callback(self, status, message, data):
        if status:
            resultJson = self.deal_powershell_json_result(data)
            windowsProductName = resultJson.get("windowsProductName").replace("WindowsServer", "Windows Server")
            windowsProductName = ((re.search("\w[\w|\s]+\d+[\s|$]", windowsProductName).group()).strip()).replace(
                "Microsoft", "").strip()
            windowsVersion = resultJson.get("windowsVersion")
            KBList = []
            for kb in resultJson.get("KBList").split():
                KBList.append(kb.replace("KB", ""))
            self.select_CVE(KBList=KBList, windowsProductName=windowsProductName, windowsVersion=windowsVersion)
            self.log_good("模块执行完成")
        else:
            self.log_error("模块执行失败")
            self.log_error(message)
